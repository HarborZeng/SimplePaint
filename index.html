<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Harbor Paint</title>
    <link rel="stylesheet" href="css/paint-style.css"/>
</head>
<body>
<div class="container">
    <nav class="banner">

        <a class="paint-title" href="index.html">Harbor画板</a>

        <div class="function-bar">
            <ul class="function-list">
                <li class="paint-function" id="open-action" onclick="openSelected()">打开</li>
                <li class="paint-function" id="save-action" onclick="saveSelected()">保存</li>
                <li class="paint-function">
                    <span>画笔形状</span>
                    <ul class="submenu-list" onclick="shapeSelected()">
                        <li class="paint-function submenu-item" id="curve-shape">曲线</li>
                        <li class="paint-function submenu-item" id="line-shape">直线</li>
                        <li class="paint-function submenu-item" id="circle-shape">圆</li>
                        <li class="paint-function submenu-item" id="oval-shape">椭圆</li>
                        <li class="paint-function submenu-item" id="rectangle-shape">矩形</li>
                    </ul>
                </li>
                <li class="paint-function">
                    <span>画笔粗细</span>
                    <ul class="submenu-list" onclick="penTypeSelected()">
                        <li class="paint-function submenu-item" id="very_thin-pen">很细</li>
                        <li class="paint-function submenu-item" id="thin-pen">细</li>
                        <li class="paint-function submenu-item" id="normal-pen">普通</li>
                        <li class="paint-function submenu-item" id="bold-pen">粗</li>
                        <li class="paint-function submenu-item" id="very_bold-pen">很粗</li>
                    </ul>
                </li>
                <li class="paint-function">
                    <span>画笔颜色</span>
                    <ul class="submenu-list" onclick="penColorSelected()">
                        <li class="paint-function submenu-item" id="blue-pen_color">蓝色</li>
                        <li class="paint-function submenu-item" id="black-pen_color">黑色</li>
                        <li class="paint-function submenu-item" id="purple-pen_color">紫色</li>
                        <li class="paint-function submenu-item" id="red-pen_color">红色</li>
                        <li class="paint-function submenu-item" id="green-pen_color">绿色</li>
                        <li class="paint-function submenu-item" id="yellow-pen_color">黄色</li>
                        <li class="paint-function submenu-item" id="white-pen_color">白色</li>
                        <li class="paint-function submenu-item" id="brown-pen_color">棕色</li>
                        <li class="paint-function submenu-item" id="pink-pen_color">粉色</li>
                        <li class="paint-function submenu-item" id="grey-pen_color">灰色</li>
                        <li class="paint-function submenu-item" id="customized-pen_color">自定义</li>
                    </ul>
                </li>
                <li class="paint-function">
                    <span>橡皮镲</span>
                    <ul class="submenu-list" onclick="eraserSelected()">
                        <li class="paint-function submenu-item" id="small-eraser">小号</li>
                        <li class="paint-function submenu-item" id="normal-eraser">普通</li>
                        <li class="paint-function submenu-item" id="large-eraser">大号</li>
                        <li class="paint-function submenu-item" id="very_large-eraser">极大</li>
                    </ul>
                </li>
                <li class="paint-function" id="undo-action" onclick="erase()">undo</li>
            </ul>
        </div>

    </nav>
    <canvas id="myCanvas">Sorry, your browser doesn't support the &lt;canvas&gt;element.</canvas>
    <div>
        <pre>
            画图板：面向对象编程，只提交代码，截止时间11月30日
            1、曲线、直线、圆/椭圆、矩形
            2、画笔粗细、颜色
            3、橡皮擦，擦除形状
            4、矢量图保存、打开
        </pre>
    </div>
    <script>
        var myCanvas = (function () {
            return document.getElementById('myCanvas');
        })();
        /**
         * 原地调用初始化canvas和context对象
         * @return context canvas的context对象
         */
        var context = (function () {
            myCanvas.width = window.innerWidth - 80;
            myCanvas.height = window.innerHeight - 50;
            return myCanvas.getContext('2d');
        })();


        //↓↓↓↓↓↓↓↓↓↓Menu父类定义begins↓↓↓↓↓↓↓↓↓↓
        /**
         * 菜单对象的父类
         * @constructor 空
         */
        function Menu() {
        }

        /**
         * 给菜单对象添加原形name
         * @type {string} name的值
         */
        Menu.prototype.name = 'menu';
        /**
         * 给菜单对象添加原形items
         * @type {{default_item: string}}
         * 是一个列表对象，代表
         */
        Menu.prototype.items = {
            default_item: ''
        };
        Menu.prototype.getCurrent = function () {
            return this.items.default_item;
        };
        Menu.prototype.setCurrent = function (selection) {
            this.items.default_item = selection;
        };
        Menu.prototype.getItems = function () {
            return this.items;
        };
        Menu.prototype.menuItemSelected = function (selection) {
            this.setCurrent(selection);
        };
        Menu.prototype.toString = function () {
            return this.name + ' has ' + this.items;
        };

        //↑↑↑↑↑↑↑↑↑↑↑↑Menu父类定义ends↑↑↑↑↑↑↑↑↑↑↑↑


        /**
         * extend函数用来模拟继承，解决子对象和父对象指向同一个对象，
         * 子对象修改原型，父对象也会被修改的不足之处
         * @param Child 子类
         * @param Parent 父类
         */
        function extend(Child, Parent) {
            var F = function () {
            };
            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.prototype.constructor = Child;
            Child.uber = Parent.prototype;
        }

        //↓↓↓↓↓↓↓↓↓↓ShapeMenu子类定义begins↓↓↓↓↓↓↓↓↓↓
        function ShapeMenu() {
        }

        extend(ShapeMenu, Menu);

        ShapeMenu.prototype.name = 'shape menu';
        ShapeMenu.prototype.items = {
            curve: 'curve-shape',
            line: 'line-shape',
            circle: 'circle-shape',
            oval: 'oval-shape',
            rectangle: 'rectangle-shape',
            default_item: 'curve-shape'
        };
        //↑↑↑↑↑↑↑↑↑↑↑↑ShapeMenu子类定义ends↑↑↑↑↑↑↑↑↑↑↑↑

        //↓↓↓↓↓↓↓↓↓↓PenType子类定义begins↓↓↓↓↓↓↓↓↓↓
        function PenTypeMenu() {
        }

        extend(PenTypeMenu, Menu);

        PenTypeMenu.prototype.name = 'Pen Type Menu';
        PenTypeMenu.prototype.items = {
            veryThin: 'very_thin-pen',
            thin: 'thin-pen',
            normal: 'normal-pen',
            bold: 'bold-pen',
            veryBold: 'very_bold-pen',
            default_item: 'normal-pen'
        };
        //↑↑↑↑↑↑↑↑↑↑↑↑PenTypeMenu子类定义ends↑↑↑↑↑↑↑↑↑↑↑↑

        //↓↓↓↓↓↓PenColor子类定义begins↓↓↓↓↓↓
        function PenColorMenu() {
        }

        extend(PenColorMenu, Menu);

        PenColorMenu.prototype.name = 'Pen color Menu';
        PenColorMenu.prototype.items = {
            blue: 'blue-pen_color',
            black: 'black-pen_color',
            purple: 'purple-pen_color',
            red: 'red-pen_color',
            green: 'green-pen_color',
            yellow: 'yellow-pen_color',
            white: 'white-pen_color',
            brown: 'brown-pen_color',
            pink: 'pink-pen_color',
            grey: 'grey-pen_color',
            customized: 'customized-pen_color',
            default_item: 'black-pen_color'
        };
        //↑↑↑↑↑↑↑PenColorMenu子类定义ends↑↑↑↑↑↑↑

        //↓↓↓↓↓↓EraserMenu子类定义begins↓↓↓↓↓↓
        function EraserMenu() {
        }

        extend(EraserMenu, Menu);

        EraserMenu.prototype.name = 'Eraser Menu';
        EraserMenu.prototype.items = {
            small: 'small-eraser',
            normal: 'normal-eraser',
            large: 'large-eraser',
            veryLarge: 'very_large-eraser',
            default_item: 'normal-eraser'
        };
        //↑↑↑↑↑↑↑↑EraserMenu子类定义ends↑↑↑↑↑↑↑↑

        //↓↓↓↓↓↓点击事件类定义begins↓↓↓↓↓↓
        function openSelected() {
            //TODO 打开localStorage存储的文件
        }

        function saveSelected() {
            //TODO 使用localStorage来存储当前画布上的对象
        }

        /**
         * shapeSelected是一个在html代码中onclick定义的函数，
         * 使用事件传递的方式获取定位到事件源，将ShapeMenu对象
         * 里面的默认值改成点击的值，值就是id
         **/
        function shapeSelected() {
            var shapeID = event.target.id;
            shapeMenu = new ShapeMenu();
            shapeMenu.menuItemSelected(shapeID);
            menuSelected(shapeMenu);
        }

        /**
         * penTypeSelected是一个在html代码中onclick定义的函数，
         * 使用事件传递的方式获取定位到事件源，将PenTypeMenu对象
         * 里面的默认值改成点击的值，值就是id
         **/
        function penTypeSelected() {
            var penTypeID = event.target.id;
            penTypeMenu = new PenTypeMenu();
            penTypeMenu.menuItemSelected(penTypeID);
            menuSelected(penTypeMenu);
        }

        /**
         * penColorSelected是一个在html代码中onclick定义的函数，
         * 使用事件传递的方式获取定位到事件源，将PenColorMenu对象
         * 里面的默认值改成点击的值，值就是id
         **/
        function penColorSelected() {
            var penColorID = event.target.id;
            penColorMenu = new PenColorMenu();
            penColorMenu.menuItemSelected(penColorID);
            menuSelected(penColorMenu);
        }

        /**
         * eraserSelected是一个在html代码中onclick定义的函数，
         * 使用事件传递的方式获取定位到事件源，将EraserMenu对象
         * 里面的默认值改成点击的值，值就是id
         **/
        function eraserSelected() {
            var eraserID = event.target.id;
            eraserMenu = new EraserMenu();
            eraserMenu.menuItemSelected(eraserID);
            menuSelected(eraserMenu);
        }

        //↑↑↑↑↑↑↑↑↑点击事件类定义ends↑↑↑↑↑↑↑↑↑


        /**
         * 该函数为shapeSelected，penTypeSelected，penColorSelected和
         * eraserSelected函数内部的共同调用
         *
         * 主要作用为清除之前的选择，给新的选择加特效
         *
         * @param menu 点击的那个需要加特效的菜单项的母菜单
         **/
        function menuSelected(menu) {
            var items = menu.getItems();
            var keys = Object.keys(items);
            clearPreviousSelection(keys, items);

            var selectedID = menu.getCurrent();
            var selection = document.getElementById(selectedID);
            selection.style.color = '#548248';
            selection.style.background = '#333';
            selection.style.fontWeight = 'bold';
        }

        /**
         * 清除之前的选择
         *
         * @param keys 选中的那个菜单项对应的母菜单下所有的菜单项的ID组成的数组
         *             的‘键’集合
         * @param items 选中的那个菜单项对应的母菜单下所有的菜单项的ID组成的数组
         **/
        function clearPreviousSelection(keys, items) {
            for (var i = 0; i < keys.length; i++) {
                var id = document.getElementById(items[keys[i]]);
                id.style.color = '#b7b7b7';
                id.style.background = '#222';
                id.style.fontWeight = 'normal';
            }
        }

        /**
         * 四个全局的变量，代表四个主要的菜单对象
         **/
        var shapeMenu;
        var penTypeMenu;
        var penColorMenu;
        var eraserMenu;

        /**
         * 初始化菜单的默认选择
         */
        (function initSelection() {
            shapeMenu = new ShapeMenu();
            menuSelected(shapeMenu);
            penTypeMenu = new PenTypeMenu();
            menuSelected(penTypeMenu);
            penColorMenu = new PenColorMenu();
            menuSelected(penColorMenu);
            eraserMenu = new EraserMenu();
            menuSelected(eraserMenu);
        })();


        /**
         *Shape为所有绘制的图形的父类，存放了子类都有的变量
         * @param originalX 记录绘制当前图形的originalX
         * @param originalY 记录绘制当前图形的originalY
         * @param nowX 记录绘制当前图形的nowX
         * @param nowY 记录绘制当前图形的nowY
         * @param context 用context保存Shape实现类的状态属性，
         *                照顾到曲线在擦除时的特殊性，降低程序耦合度
         * @param name 记录绘制当前图形的名字代号
         * @constructor
         */
        function Shape(originalX, originalY, nowX, nowY, context, name) {
            this.originalX = originalX;
            this.originalY = originalY;
            this.nowX = nowX;
            this.nowY = nowY;
            this.context = context;
            this.name = name;
        }

        //↑↑↑↑↑↑↑↑↑↑↑↑Shape父类定义ends↑↑↑↑↑↑↑↑↑↑↑↑

        /**
         * 直线对象的定义，其构造函数完全复用父类
         * @param originalX 记录绘制当前图形的originalX
         * @param originalY 记录绘制当前图形的originalY
         * @param nowX 记录绘制当前图形的nowX
         * @param nowY 记录绘制当前图形的nowY
         * @param context 用context保存Shape实现类的状态属性，
         *                照顾到曲线在擦除时的特殊性，降低程序耦合度
         * @param name 记录绘制当前图形的名字代号
         * @constructor
         */
        function Line(originalX, originalY, nowX, nowY, context, name) {
            Shape.call(this, originalX, originalY, nowX, nowY, context, name);
        }

        extend(Line, Shape);

        Line.prototype.draw = function () {
            this.context.beginPath();
            this.context.moveTo(this.originalX, this.originalY);
            this.context.lineTo(this.nowX, this.nowY);
            this.context.stroke();
            this.context.closePath();
        };

        /**
         * 矩形对象的定义，其构造函数完全复用父类
         * @param originalX 记录绘制当前图形的originalX
         * @param originalY 记录绘制当前图形的originalY
         * @param nowX 记录绘制当前图形的nowX
         * @param nowY 记录绘制当前图形的nowY
         * @param context 用context保存Shape实现类的状态属性，
         *                照顾到曲线在擦除时的特殊性，降低程序耦合度
         * @param name 记录绘制当前图形的名字代号
         * @constructor
         */
        function Rectangle(originalX, originalY, nowX, nowY, context, name) {
            Shape.call(this, originalX, originalY, nowX, nowY, context, name);
        }

        extend(Rectangle, Shape);
        Rectangle.prototype.draw = function () {
            this.context.strokeRect(this.originalX, this.originalY,
                this.nowX - this.originalX, this.nowY - this.originalY);
        };

        /**
         * 圆形对象的定义，其构造函数完全复用父类
         * @param originalX 记录绘制当前图形的originalX
         * @param originalY 记录绘制当前图形的originalY
         * @param nowX 记录绘制当前图形的nowX
         * @param nowY 记录绘制当前图形的nowY
         * @param context 用context保存Shape实现类的状态属性，
         *                照顾到曲线在擦除时的特殊性，降低程序耦合度
         * @param name 记录绘制当前图形的名字代号
         * @constructor
         */
        function Circle(originalX, originalY, nowX, nowY, context, name) {
            Shape.call(this, originalX, originalY, nowX, nowY, context, name);
        }

        extend(Circle, Shape);
        Circle.prototype.draw = function () {

            var radius = Math.sqrt(
                Math.pow(Math.abs(this.nowX - this.originalX) / 2, 2)
                + Math.pow(Math.abs(this.nowY - this.originalY) / 2, 2)
            );
            var centerX = this.originalX
                + (this.nowX - this.originalX) / 2;
            var centerY = this.originalY
                + (this.nowY - this.originalY) / 2;

            this.context.beginPath();
            this.context.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
            this.context.stroke();
            this.context.closePath();
        };

        /**
         * 曲线对象的定义，其构造函数完全复用父类
         * @param originalX 记录绘制当前图形的originalX
         * @param originalY 记录绘制当前图形的originalY
         * @param nowX 记录绘制当前图形的nowX
         * @param nowY 记录绘制当前图形的nowY
         * @param context 用context保存Shape实现类的状态属性，
         *                照顾到曲线在擦除时的特殊性，降低程序耦合度
         * @param name 记录绘制当前图形的名字代号
         * @constructor
         */
        function Curve(originalX, originalY, nowX, nowY, context, name) {
            Shape.call(this, originalX, originalY, nowX, nowY, context, name);
        }

        extend(Curve, Shape);
        Curve.prototype.draw = function () {
            this.context.lineTo(this.nowX, this.nowY);
            this.context.stroke();
        };

        /**
         * 椭圆对象的定义，其构造函数完全复用父类
         * @param originalX 记录绘制当前图形的originalX
         * @param originalY 记录绘制当前图形的originalY
         * @param nowX 记录绘制当前图形的nowX
         * @param nowY 记录绘制当前图形的nowY
         * @param context 用context保存Shape实现类的状态属性，
         *                照顾到曲线在擦除时的特殊性，降低程序耦合度
         * @param name 记录绘制当前图形的名字代号
         * @constructor
         */
        function Oval(originalX, originalY, nowX, nowY, context, name) {
            Shape.call(this, originalX, originalY, nowX, nowY, context, name);
        }

        extend(Oval, Shape);
        Oval.prototype.draw = function () {
            var centerX = this.originalX;
            var centerY = this.originalY;
            var height = this.nowY - this.originalY;
            var width = this.nowX - this.originalX;

            this.context.beginPath();
            this.context.moveTo(centerX, centerY - height / 2);

            this.context.bezierCurveTo(
                centerX + width / 2, centerY - height / 2,
                centerX + width / 2, centerY + height / 2,
                centerX, centerY + height / 2
            );
            this.context.bezierCurveTo(
                centerX - width / 2, centerY + height / 2,
                centerX - width / 2, centerY - height / 2,
                centerX, centerY - height / 2
            );

            this.context.stroke();
            this.context.closePath();
        };

        /**
         * 鼠标对象，使用较为广泛，属性在鼠标按下和移动的时候能被更新，
         * 内含数种鼠标状态和getter setter
         * @type {{originalX: number, originalY: number, nowX: number, nowY: number, mouseStatus: string, mouseStatusList: {down: string, up: string, notDefined: string}, setMouseStatusDown: mouse.setMouseStatusDown, setMouseStatusUp: mouse.setMouseStatusUp, getMouseStatus: mouse.getMouseStatus}}
         */
        var mouse = {
            originalX: innerWidth / 2,
            originalY: innerHeight / 2,
            nowX: innerHeight / 2,
            nowY: innerHeight / 2,
            mouseStatus: 'not_defined',
            mouseStatusList: {
                down: 'down',
                up: 'up',
                notDefined: 'not_defined'
            },
            setMouseStatusDown: function () {
                this.mouseStatus = this.mouseStatusList.down;
            },
            setMouseStatusUp: function () {
                this.mouseStatus = this.mouseStatusList.up;
            },
            getMouseStatus: function () {
                return this.mouseStatus;
            }
        };

        /**
         * imageData是当前canvas扒下来的一份copy
         */
        var imageData;
        /**
         * imageStack是我们在undo的时候的依据，
         * 在undo的时候，会把imageStack给pop一下，
         * 然后遍历输出imageStack以实现undo操作
         * @type {Array}
         */
        var imageStack = [];

        /**
         * erase函数是html代码里面undo的onclick事件
         */
        function erase() {
            imageStack.pop();
            context.clearRect(0, 0, myCanvas.width, myCanvas.height);
            for (var i = 0; i < imageStack.length; i++) {
                imageStack[i].draw();
            }
            console.log(imageStack);
        }

        /**
         * 鼠标按下的时候要执行的事情
         * @param event 系统级的变量event
         */
        function myCanvasMouseDown(event) {
            console.log('mouse down');
            if (event.button === 0) {
                mouse.originalX = event.offsetX;
                mouse.nowX = event.offsetX;
                mouse.originalY = event.offsetY;
                mouse.nowY = event.offsetY;
                imageData = context
                    .getImageData(0, 0, myCanvas.width, myCanvas.height);
                mouse.setMouseStatusDown();
            }

            //先拿到当前菜单上的颜色
            if (penColorMenu.getCurrent() === penColorMenu.items.customized) {
                //TODO
            } else {
                context.strokeStyle = penColorMenu.getCurrent()
                    .substring(0, penColorMenu.getCurrent().indexOf('-'));
            }

            //再拿到当前菜单上的画笔粗细
            switch (penTypeMenu.getCurrent()) {
                case penTypeMenu.items.bold:
                    context.lineWidth = 15;
                    break;
                case penTypeMenu.items.veryBold:
                    context.lineWidth = 20;
                    break;
                case penTypeMenu.items.normal:
                    context.lineWidth = 10;
                    break;
                case penTypeMenu.items.veryThin:
                    context.lineWidth = 1;
                    break;
                case penTypeMenu.items.thin:
                    context.lineWidth = 5;
                    break;
                default:
                    console.warn('In myCanvasMouseMove choose pen type' +
                        ', went to default!!!');
            }

            switch (shapeMenu.getCurrent()) {
                case shapeMenu.items.circle:
                    //do nothing
                    break;
                case shapeMenu.items.rectangle:
                    //do nothing
                    break;
                case shapeMenu.items.line:
                    //do nothing
                    break;
                case shapeMenu.items.oval:
                    //do nothing
                    break;
                case shapeMenu.items.curve:
                    //相当于给画曲线初始化，防止画曲线出现第二笔开头连着第一笔末尾的BUG
                    context.beginPath();
                    context.moveTo(mouse.nowX, mouse.nowY);
                    break;
                default:
                    console.warn('In myCanvasMouseDown, went to default!!!');
            }
        }

        /**
         * 具体的执行画图的Controller
         * @param event
         */
        function drawShape(event) {
            context.clearRect(0, 0, myCanvas.width, myCanvas.height);
            for (var i = 0; i < imageStack.length; i++) {
                imageStack[i].draw();
            }

            mouse.nowX = event.offsetX;
            mouse.nowY = event.offsetY;

            //最后拿到菜单上选择的当前画笔画什么样的图形，并new相应对象，执行draw方法
            switch (shapeMenu.getCurrent()) {
                case shapeMenu.items.circle:
                    var circle = new Circle(mouse.originalX, mouse.originalY,
                        mouse.nowX, mouse.nowY,
                        context, 'circle');
                    circle.draw();
                    break;
                case shapeMenu.items.rectangle:
                    var rectangle = new Rectangle(mouse.originalX, mouse.originalY,
                        mouse.nowX, mouse.nowY,
                        context, 'rectangle');
                    rectangle.draw();
                    break;
                case shapeMenu.items.line:
                    var line = new Line(mouse.originalX, mouse.originalY,
                        mouse.nowX, mouse.nowY,
                        context, 'line');
                    line.draw();
                    break;
                case shapeMenu.items.curve:
                    var curve = new Curve(mouse.originalX, mouse.originalY,
                        mouse.nowX, mouse.nowY,
                        context, 'curve');
                    curve.draw();
                    break;
                case shapeMenu.items.oval:
                    var oval = new Oval(mouse.originalX, mouse.originalY,
                        mouse.nowX, mouse.nowY,
                        context, 'oval');
                    oval.draw();
                    break;
                default:
                    console.warn('In myCanvasMouseMove, went to default!!!');
            }
        }

        /**
         * 鼠标移动的时候会执行的函数
         * @param event 系统级的对象
         */
        function myCanvasMouseMove(event) {
            if (mouse.getMouseStatus() === mouse.mouseStatusList.down) {
                console.log('mouse moving on down condition');
                drawShape(event);
            }
        }

        /**
         * 鼠标抬起（其实应该叫手指抬起）的时候，执行的函数
         * 处理收尾工作，imageData入imageStack栈
         * @param event 系统级对象
         */
        function myCanvasMouseUp(event) {
            console.log('mouse up');
            if (mouse.getMouseStatus() === mouse.mouseStatusList.down) {
                drawShape(event);

                switch (shapeMenu.getCurrent()){
                    case shapeMenu.items.curve:
                        imageStack.push(new Curve(mouse.originalX, mouse.originalY,
                            mouse.nowX, mouse.nowY,
                            context, 'curve'));
                        break;
                    case shapeMenu.items.line:
                        imageStack.push(new Line(mouse.originalX, mouse.originalY,
                            mouse.nowX, mouse.nowY,
                            context, 'line'));
                        break;
                    case shapeMenu.items.circle:
                        imageStack.push(new Circle(mouse.originalX, mouse.originalY,
                            mouse.nowX, mouse.nowY,
                            context, 'circle'));
                        break;
                    case shapeMenu.items.oval:
                        imageStack.push(new Oval(mouse.originalX, mouse.originalY,
                            mouse.nowX, mouse.nowY,
                            context, 'oval'));
                        break;
                    case shapeMenu.items.rectangle:
                        imageStack.push(new Rectangle(mouse.originalX, mouse.originalY,
                            mouse.nowX, mouse.nowY,
                            context, 'rectangle'));
                        break;
                }

                console.log(imageStack);

                mouse.setMouseStatusUp();
                mouse.nowX = null;
                mouse.nowY = null;
            }
        }

        /**
         * 这三个函数是用来给myCanvas绑定事件的，三个事件详见上面代码
         */
        myCanvas.addEventListener('mousedown', myCanvasMouseDown);
        myCanvas.addEventListener('mouseup', myCanvasMouseUp);
        myCanvas.addEventListener('mousemove', myCanvasMouseMove);
    </script>
</div>
</body>
</html>